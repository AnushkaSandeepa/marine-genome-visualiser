lines(density(psi))
abline(v = 1.15, lty = 2, lwd = 2)
text(1.15, par("usr")[4]*0.9, "1.15", pos = 4)
# Wrap psi into a pseudo posterior object
posterior_psi <- as_draws_array(data.frame(psi = psi))
library(rstan)
library(bayesplot)
library(rstan)
library(bayesplot)
install.packages("tinytex")   # if needed
library(tinytex)
# If TinyTeX is half-installed, remove and reinstall:
if (tinytex::is_tinytex()) tinytex::uninstall_tinytex()
tinytex::install_tinytex(force = TRUE)
tinytex::tlmgr_path(add = TRUE)   # add TinyTeX bin to PATH
tinytex::tlmgr_path()
tinytex::latex_path()            # should point to .../.TinyTeX/bin/win32/xelatex
tinytex::tlmgr("path", "add")
tt <- tinytex::tinytex_root()                     # e.g. "C:/Users/ASUS_TUF/AppData/Roaming/TinyTeX"
bin <- file.path(tt, "bin", "win32")
Sys.setenv(PATH = paste(bin, Sys.getenv("PATH"), sep=";"))
tinytex::latex_path()            # should point to .../.TinyTeX/bin/win32/xelatex
knitr::opts_chunk$set(
fig.crop = FALSE,   # don’t call pdfcrop
dev = "png",
fig.ext = "png"
)
install.packages("magick")
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE,
fig.crop = FALSE,
dev = "png",
fig.ext = "png"
)
install.packages("magick")
# Option 1: sigma ≈ 0.085
sigma_star1 <- 0.085
res_d1 <- mh_run(n_iter = 10000, sigma = sigma_star1, p_init = 0.20, s = s, n = n)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE,
fig.crop = FALSE,
dev = "png",
fig.ext = "png"
)
y_vals <- 1:12
freq   <- c(29,16,17,4,3,9,4,5,1,1,1,3)
n <- sum(freq)
s <- sum(freq * y_vals)
p_mle <- n / s
probit    <- function(p) qnorm(p)
invprobit <- function(x) pnorm(x)
logpost <- function(p, s, n) {
if (p <= 0 || p >= 1) return(-Inf)
(s - n) * log1p(-p) + n * log(p)
}
mh_run <- function(n_iter, sigma, p_init, s, n) {
draws <- numeric(n_iter); draws[1] <- p_init
lp_prev <- logpost(draws[1], s, n)
u_prev  <- probit(draws[1])
accepts <- 0L
for (t in 2:n_iter) {
w    <- rnorm(1, mean = u_prev, sd = sigma)
x    <- invprobit(w)
lp_x <- logpost(x, s, n)
log_q_ratio <- dnorm(u_prev, log = TRUE) - dnorm(w, log = TRUE)
logA <- (lp_x - lp_prev) + log_q_ratio
if (log(runif(1)) < logA) {
draws[t] <- x; lp_prev <- lp_x; u_prev <- w; accepts <- accepts + 1L
} else {
draws[t] <- draws[t-1]
}
}
list(draws = draws, acc_rate = accepts/(n_iter - 1))
}
# --- Run chain with sigma = 0.01 ---
res_b <- mh_run(n_iter = 10000, sigma = 0.01, p_init = 0.20, s = s, n = n)
# Acceptance (percent)
acc_b <- 100 * res_b$acc_rate
acc_b  # <- report this (round to 1 d.p. in LMS answer)
# Trace plot
plot(res_b$draws, type = "l",
main = sprintf("RW–MH Trace (sigma = 0.01), acc = %.1f%%;  MLE = %.3f", acc_b, p_mle),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "gray40")
mean(res_b$draws); sd(res_b$draws)
acf(res_b$draws, lag.max = 40)
# Run RW-MH with σ = 5
res_c <- mh_run(n_iter = 10000, sigma = 5, p_init = 0.30, s = s, n = n)
# Acceptance rate
acc_c <- 100 * res_c$acc_rate
acc_c
# Trace plot
plot(res_c$draws, type = "l",
main = sprintf("RW–MH Trace (sigma = 5), acc = %.1f%%;  MLE = %.3f", acc_c, p_mle),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "blue")
# Coarse grid over sigma (log-scale)
grid_sigma <- 10^seq(-3, 0, length.out = 15)  # 0.001 ... 1
# Short pilot runs to estimate acceptance rates
pilot_accept <- sapply(grid_sigma, function(sg) {
mh_run(n_iter = 4000, sigma = sg, p_init = 0.20, s = s, n = n)$acc_rate
})
# Choose sigma whose acceptance is closest to 0.70
sigma_star <- grid_sigma[ which.min(abs(pilot_accept - 0.70)) ]
# Show the grid and acceptances (rounded) for the report appendix if needed
data.frame(sigma = signif(grid_sigma, 3), acc_rate = round(pilot_accept, 3))
round(sigma_star,3)
# Option 1: sigma ≈ 0.085
sigma_star1 <- 0.085
res_d1 <- mh_run(n_iter = 10000, sigma = sigma_star1, p_init = 0.20, s = s, n = n)
acc_d1 <- 100 * res_d1$acc_rate
round(acc_d1, 1)
plot(res_d1$draws, type = "l",
main = sprintf("RW–MH Trace (sigma = %.4f), acc = %.1f%%; MLE = %.3f",
sigma_star1, acc_d1, p_mle),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "blue")
# Option 2: sigma ≈ 0.052
sigma_star2 <- 0.052
res_d2 <- mh_run(n_iter = 10000, sigma = sigma_star2, p_init = 0.20, s = s, n = n)
acc_d2 <- 100 * res_d2$acc_rate
round(acc_d2, 1)
plot(res_d2$draws, type = "l",
main = sprintf("RW–MH Trace (sigma = %.4f), acc = %.1f%%; MLE = %.3f",
sigma_star2, acc_d2, p_mle),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "green")
# Coarse grid over sigma (log-scale)
grid_sigma <- 10^seq(-3, 0, length.out = 15)  # 0.001 ... 1
# Short pilot runs to estimate acceptance rates
pilot_accept <- sapply(grid_sigma, function(sg) {
mh_run(n_iter = 4000, sigma = sg, p_init = 0.20, s = s, n = n)$acc_rate
})
# Coarse grid over sigma (log-scale)
grid_sigma <- 10^seq(-3, 0, length.out = 15)  # 0.001 ... 1
# Short pilot runs to estimate acceptance rates
pilot_accept <- sapply(grid_sigma, function(sg) {
mh_run(n_iter = 4000, sigma = sg, p_init = 0.20, s = s, n = n)$acc_rate
})
# Choose sigma whose acceptance is closest to 0.70
sigma_star <- grid_sigma[ which.min(abs(pilot_accept - 0.70)) ]
# Show the grid and acceptances (rounded) for the report appendix if needed
data.frame(sigma = signif(grid_sigma, 3), acc_rate = round(pilot_accept, 3))
round(sigma_star,3)
# Use sigma_star found from your pilot grid (closest to 0.70 acceptance)
# Example: sigma_star already computed earlier
res_d <- mh_run(n_iter = 10000, sigma = sigma_star, p_init = 0.20, s = s, n = n)
acc_d <- 100 * res_d$acc_rate
acc_d   # <- report to 1 d.p.
sigma_star  # <- report to 2–3 s.f.
plot(res_d$draws, type = "l",
main = sprintf("RW–MH Trace (tuned sigma ≈ %.4g), acc = %.1f%%; start p(1)=0.20; MLE = %.3f",
sigma_star, acc_d, p_mle),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "gray40")
# Compare both step sizes side by side
par(mfrow = c(1, 2))  # 1 row, 2 columns
# Option 1: sigma ≈ 0.085
sigma_star1 <- 0.085
res_d1 <- mh_run(n_iter = 10000, sigma = sigma_star1, p_init = 0.20, s = s, n = n)
acc_d1 <- 100 * res_d1$acc_rate
plot(res_d1$draws, type = "l",
main = sprintf("σ = %.3f, acc = %.1f%%", sigma_star1, acc_d1),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "blue")
# Option 2: sigma ≈ 0.052
sigma_star2 <- 0.052
res_d2 <- mh_run(n_iter = 10000, sigma = sigma_star2, p_init = 0.20, s = s, n = n)
acc_d2 <- 100 * res_d2$acc_rate
plot(res_d2$draws, type = "l",
main = sprintf("σ = %.3f, acc = %.1f%%", sigma_star2, acc_d2),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "green")
# Reset plotting layout
par(mfrow = c(1, 1))
# Compare both step sizes side by side
par(mfrow = c(1, 2))  # 1 row, 2 columns
# Option 1: sigma ≈ 0.085
sigma_star1 <- 0.085
res_d1 <- mh_run(n_iter = 10000, sigma = sigma_star1, p_init = 0.20, s = s, n = n)
acc_d1 <- 100 * res_d1$acc_rate
plot(res_d1$draws, type = "l",
main = sprintf("σ = %.3f, acc = %.1f%%", sigma_star1, acc_d1),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "blue")
# Option 2: sigma ≈ 0.052
sigma_star2 <- 0.052
res_d2 <- mh_run(n_iter = 10000, sigma = sigma_star2, p_init = 0.20, s = s, n = n)
acc_d2 <- 100 * res_d2$acc_rate
plot(res_d2$draws, type = "l",
main = sprintf("σ = %.3f, acc = %.1f%%", sigma_star2, acc_d2),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "green")
# Reset plotting layout
par(mfrow = c(1, 1))
# Compare both step sizes side by side
par(mfrow = c(1, 2))  # 1 row, 2 columns
# Option 1: sigma ≈ 0.085
sigma_star1 <- 0.085
res_d1 <- mh_run(n_iter = 10000, sigma = sigma_star1, p_init = 0.20, s = s, n = n)
acc_d1 <- 100 * res_d1$acc_rate
plot(res_d1$draws, type = "l",
main = sprintf("σ = %.3f, acc = %.1f%%", sigma_star1, acc_d1),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "blue")
# Option 2: sigma ≈ 0.052
sigma_star2 <- 0.052
res_d2 <- mh_run(n_iter = 10000, sigma = sigma_star2, p_init = 0.20, s = s, n = n)
acc_d2 <- 100 * res_d2$acc_rate
plot(res_d2$draws, type = "l",
main = sprintf("σ = %.3f, acc = %.1f%%", sigma_star2, acc_d2),
xlab = "Iteration", ylab = "p")
abline(h = p_mle, lty = 2, col = "green")
# Reset plotting layout
par(mfrow = c(1, 1))
# Uses n, s, p_mle defined earlier
# Grid of gamma values: gamma_k = 2^k for k = -1,...,18
k_vals <- -1:18
gamma  <- 2^k_vals
# Posterior mean under Beta(gamma, gamma) prior with FS likelihood:
# posterior ~ Beta(gamma + n, gamma + s - n)
# estimate (posterior mean) = (gamma + n) / (2*gamma + s)
p_hat  <- (gamma + n) / (2*gamma + s)
# Quick table (optional)
data.frame(k = k_vals, gamma = gamma, p_hat = round(p_hat, 4))
# Plot p_hat vs log(gamma)
plot(log(gamma), p_hat, type = "b", pch = 19,
xlab = "log(gamma)", ylab = "Posterior mean estimate of p",
main = "Prior influence: Beta(gamma, gamma)")
abline(h = p_mle, lty = 2, col = "gray40")
legend("bottomright", bty = "n",
legend = c(sprintf("MLE ≈ %.3f", p_mle)),
lty = 2, col = "gray40", cex = 0.9)
# Number of rats (rows) and weeks (columns)
n_rats  <- nrow(y)
# Build the data list
data_list <- list(N = length(y_vec), x = x_vec, y = y_vec)
library(rstan)
library(bayesplot)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
dat <- read.csv("rats-ctt.csv")
str(dat)
x <- 0:4
y <- data.matrix(dat[,-(1:2)])
matplot(x, t(y), col = "black", pch = 20)
library(matrixStats)
(SDs <- colSds(y))
# SD vs x  → linear SD link candidate: sigma = gamma0 + gamma1 * x
plot(x, SDs, pch = 19, main = "SD vs x")
abline(lm(SDs ~ x), col = "grey")
# log(SD) vs x  → log-linear SD link candidate: sigma = exp(gamma0 + gamma1 * x)
plot(x, log(SDs), pch = 19, main = "log SD vs x")
abline(lm(log(SDs) ~ x), col = "grey")
# log(SD) vs log(x+1)  → power-law SD link candidate: sigma = exp(gamma0) * (1+x)^{gamma1}
lx  <- log(x + 1)
lsd <- log(SDs)
plot(lx, lsd, pch = 19, xlab = "log(x+1)", ylab = "log SD", main = "log SD vs log(x+1)")
abline(lm(lsd ~ lx), col = "grey")
# SD vs x  → linear SD link candidate: sigma = gamma0 + gamma1 * x
plot(x, SDs, pch = 19, main = "SD vs x")
abline(lm(SDs ~ x), col = "grey")
# Number of rats (rows) and weeks (columns)
n_rats  <- nrow(y)
n_weeks <- ncol(y)
x_vec <- rep(x, each = n_rats)
y_vec <- as.vector(t(y))
# Quick alignment checks
stopifnot(length(x_vec) == length(y_vec))
stopifnot(all(x_vec %in% x))
N <- length(y_vec)
str(list(N=N, x=x_vec[1:10], y=y_vec[1:10]))  # peek
# Build the data list
data_list <- list(N = length(y_vec), x = x_vec, y = y_vec)
# Sample (keep in its own chunk)
fit <- sampling(rats_mod, data = data_list, chains = 4, iter = 2000, warmup = 1000)
# Summaries (report rounded means/CrIs in LMS)
print(fit, pars = c("alpha","beta","gamma0","gamma1"),
probs = c(0.05, 0.5, 0.95), digits = 3)
:contentReference[oaicite:0]{index=0}
x_vec <- rep(x, each = nrow(y))
y_vec <- as.vector(t(y))
data_list <- list(N = length(y_vec), x = x_vec, y = y_vec)
str(data_list)
fit <- sampling(rats_mod, data = data_list,
chains = 4, iter = 2000, warmup = 1000)
# Summaries (report rounded means/CrIs in LMS)
print(fit, pars = c("alpha","beta","gamma0","gamma1"),
probs = c(0.05, 0.5, 0.95), digits = 3)
check_hmc_diagnostics(fit)
posterior <- as.array(fit)
bayesplot::mcmc_trace(posterior, pars = c("alpha","beta","gamma0","gamma1"))
post <- as.array(fit)
bayesplot::mcmc_trace(post, pars = c("alpha","beta","gamma0","gamma1"))
check_hmc_diagnostics(fit)
post <- as.array(fit)
bayesplot::mcmc_trace(post, pars = c("alpha","beta","gamma0","gamma1"))
fit <- sampling(rats_mod, data = data_list,
chains = 4, iter = 2000, warmup = 1000)
# Summaries (report rounded means/CrIs in LMS)
print(fit, pars = c("alpha","beta","gamma0","gamma1"),
probs = c(0.05, 0.5, 0.95), digits = 3)
# Small helper to extract mean + 90% CrI for given pars
summ_90 <- function(fit, pars = c("alpha","beta")) {
s <- summary(fit, pars = pars, probs = c(0.05, 0.5, 0.95))$summary
data.frame(
Parameter = rownames(s),
Mean      = round(s[,"mean"], 3),
CrI90_L   = round(s[,"5%"],   3),
Median    = round(s[,"50%"],  3),
CrI90_U   = round(s[,"95%"],  3),
row.names = NULL
)
}
tab_lab5 <- cbind(Model = "Lab 5 (homoscedastic)", summ_90(fit_lab5))
shiny::runApp('C:/Users/ASUS_TUF/OneDrive - UWA/Lecrure Contents/S4/Capstone Project/marine-genome-visualiser')
shiny::runApp()
runApp()
# Make that specific jsonlite warning throw (to get a stack trace)
options(warn = 2)
# Trace jsonlite's internal asJSON.default so we can print the offending object
if (!"jsonlite" %in% loadedNamespaces()) library(jsonlite)
trace(jsonlite:::asJSON.default,
tracer = quote({
if (is.atomic(x) && !is.null(names(x))) {
cat("\n===== Found NAMED ATOMIC VECTOR going to json =====\n")
print(x)                 # show the actual vector
cat("\nClasses:", paste(class(x), collapse=", "), "\n")
cat("\nBacktrace:\n")
print(sys.calls())       # where it comes from (which render/output)
cat("====================================================\n")
}
}),
print = FALSE
)
later: exception occurred while executing callback:
later: exception occurred while executing callback:
# 1) Restart R/session first, then run ONLY this:
options(warn = 2)              # turn that jsonlite warning into an error so we get a stack
library(jsonlite)
# Trace jsonlite:::asJSON.default and print the offending vector + backtrace
trace("asJSON.default",
where = asNamespace("jsonlite"),
tracer = quote({
if (is.atomic(x) && !is.null(names(x))) {
cat("\n===== Named atomic vector sent to JSON =====\n")
print(x)
cat("\nClasses:", paste(class(x), collapse = ", "), "\n")
cat("\nBacktrace:\n")
print(sys.calls())
cat("============================================\n")
}
}),
print = FALSE)
options(warn = 2)   # make that warning throw so we get a stack trace
library(jsonlite)
# See what jsonlite actually has registered for asJSON():
methods("asJSON")
# Restart R first, then paste everything below:
options(warn = 2)        # make the warning throw so we get a stack
library(jsonlite)
# Helper to walk any R object and scream if it finds a named atomic vector
.find_named_atomic <- function(obj, path = "x") {
if (is.atomic(obj) && !is.null(names(obj))) {
cat("\n===== Named atomic vector found =====\n")
cat("Path: ", path, "\n", sep = "")
print(obj)
cat("Classes:", paste(class(obj), collapse = ", "), "\n")
cat("Backtrace:\n"); print(sys.calls())
cat("=====================================\n")
stop("Named atomic vector passed to jsonlite::toJSON (see console above)", call. = FALSE)
}
if (is.list(obj)) {
# named or unnamed list — recurse into each element
idx <- names(obj)
if (is.null(idx)) idx <- seq_along(obj)
for (i in seq_along(obj)) {
.find_named_atomic(obj[[i]], paste0(path, "$", idx[i]))
}
} else if (is.data.frame(obj)) {
for (nm in names(obj)) .find_named_atomic(obj[[nm]], paste0(path, "$", nm))
}
invisible(NULL)
}
# Trace jsonlite::toJSON to inspect its 'x' argument before it serializes
trace("toJSON", where = asNamespace("jsonlite"),
tracer = quote({
if (exists("x", inherits = FALSE)) {
.find_named_atomic(x, "toJSON$x")
}
}),
print = FALSE
)
# Restart R first, then paste everything below:
options(warn = 2)        # make the warning throw so we get a stack
library(jsonlite)
# Helper to walk any R object and scream if it finds a named atomic vector
.find_named_atomic <- function(obj, path = "x") {
if (is.atomic(obj) && !is.null(names(obj))) {
cat("\n===== Named atomic vector found =====\n")
cat("Path: ", path, "\n", sep = "")
print(obj)
cat("Classes:", paste(class(obj), collapse = ", "), "\n")
cat("Backtrace:\n"); print(sys.calls())
cat("=====================================\n")
stop("Named atomic vector passed to jsonlite::toJSON (see console above)", call. = FALSE)
}
if (is.list(obj)) {
# named or unnamed list — recurse into each element
idx <- names(obj)
if (is.null(idx)) idx <- seq_along(obj)
for (i in seq_along(obj)) {
.find_named_atomic(obj[[i]], paste0(path, "$", idx[i]))
}
} else if (is.data.frame(obj)) {
for (nm in names(obj)) .find_named_atomic(obj[[nm]], paste0(path, "$", nm))
}
invisible(NULL)
}
# Trace jsonlite::toJSON to inspect its 'x' argument before it serializes
trace("toJSON", where = asNamespace("jsonlite"),
tracer = quote({
if (exists("x", inherits = FALSE)) {
.find_named_atomic(x, "toJSON$x")
}
}),
print = FALSE
)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
# 0) Fresh session. DO NOT set options(warn = 2)
library(jsonlite)
# Recursive inspector: throws if it finds a named atomic vector
.find_named_atomic <- function(obj, path = "x") {
if (is.atomic(obj) && !is.null(names(obj))) {
cat("\n===== Named atomic vector found =====\n")
cat("Path: ", path, "\n", sep = "")
print(obj)
cat("Classes:", paste(class(obj), collapse = ", "), "\n")
cat("Backtrace:\n"); print(sys.calls())
cat("=====================================\n")
stop("Named atomic vector passed to jsonlite::toJSON (see console above)",
call. = FALSE)
}
if (is.list(obj)) {
idx <- names(obj); if (is.null(idx)) idx <- seq_along(obj)
for (i in seq_along(obj)) .find_named_atomic(obj[[i]], paste0(path, "$", idx[i]))
} else if (is.data.frame(obj)) {
for (nm in names(obj)) .find_named_atomic(obj[[nm]], paste0(path, "$", nm))
}
invisible(NULL)
}
# Trace the public entry point
trace("toJSON", where = asNamespace("jsonlite"),
tracer = quote({
if (exists("x", inherits = FALSE)) .find_named_atomic(x, "toJSON$x")
}),
print = FALSE
)
# Now load shiny (no warn=2, so startup warnings won't error)
library(shiny)
# 0) Fresh session. DO NOT set options(warn = 2)
library(jsonlite)
# Recursive inspector: throws if it finds a named atomic vector
.find_named_atomic <- function(obj, path = "x") {
if (is.atomic(obj) && !is.null(names(obj))) {
cat("\n===== Named atomic vector found =====\n")
cat("Path: ", path, "\n", sep = "")
print(obj)
cat("Classes:", paste(class(obj), collapse = ", "), "\n")
cat("Backtrace:\n"); print(sys.calls())
cat("=====================================\n")
stop("Named atomic vector passed to jsonlite::toJSON (see console above)",
call. = FALSE)
}
if (is.list(obj)) {
idx <- names(obj); if (is.null(idx)) idx <- seq_along(obj)
for (i in seq_along(obj)) .find_named_atomic(obj[[i]], paste0(path, "$", idx[i]))
} else if (is.data.frame(obj)) {
for (nm in names(obj)) .find_named_atomic(obj[[nm]], paste0(path, "$", nm))
}
invisible(NULL)
}
# Trace the public entry point
trace("toJSON", where = asNamespace("jsonlite"),
tracer = quote({
if (exists("x", inherits = FALSE)) .find_named_atomic(x, "toJSON$x")
}),
print = FALSE
)
# Now load shiny (no warn=2, so startup warnings won't error)
library(shiny)
shiny::runApp()
install.packages("curl")      # get latest (>= 5.x)
install.packages("httr2")     # get latest compatible with curl
restart R
install.packages("curl")
install.packages("httr2")
runApp()
shiny::runApp()
install.packages(c("curl","httr2"))
install.packages(c("curl", "httr2"))
packageVersion("curl")   # should be recent (e.g., 6.x/7.x)
packageVersion("httr2")  # recent (1.x)
curl::curl_version()
shiny::runApp()
